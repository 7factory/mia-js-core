/**
 *
 *
 */

var _ = require('lodash');
//base class
var Q = require('q');
var Shared = require("mia-js-core/node_modules/shared");
var BaseClass = require("mia-js-core/node_modules/baseClass");
var ModelValidator = require("mia-js-core/node_modules/modelValidator");
var Utils = require("mia-js-core/node_modules/utils");
var Qext = Utils.Qext;
var Logger = require("mia-js-core/node_modules/utils");
var ArgumentHelpers = Utils.ArgumentHelpers;
var MemberHelpers = Utils.MemberHelpers;
var Async = require('async');

function thisModule() {

    /**
     * Base class for all models
     */
    var baseModel = BaseClass.extend({
            //==================================
            // Instance members
            //==================================
            /**
             * Assigns values to model instance's 'data' property. Overwrites previous 'data' on success.
             *
             * Options
             *  - **validate**, data validation according to schema. If not specified is set to 'true', on explicit 'false' validation is skipped.
             *
             * @param values
             * @param [options]
             * @param [callback]
             */
            setValues: function (values, options, callback) {
                var self = this;
                var deferred = Q.defer();

                var args = ArgumentHelpers.prepareArguments(options, callback);
                options = args.options;
                callback = Qext.makeNodeResolver(deferred, args.callback);

                if (options.validate === false) {
                    //assign unvalidated values
                    self.data = values;
                    callback(null, values);
                }
                else {
                    self.schema.validate(values, options, function (err, validatedValues) {
                        if (!err) {
                            //assign validated values
                            self.data = validatedValues;
                        }
                        callback(err, validatedValues);
                    });
                }

                return deferred.promise;
            },

            /**
             * Assigns values to model instance's 'data' property, validates data and inserts instance directly into DB (only on successful validation).
             * Takes the union of options, which setValues and insert take.
             *
             * @param values
             * @param [options]
             * @param [callback]
             */
            setValuesAndInsert: function (values, options, callback) {
                var self = this;
                var deferred = Q.defer();

                var args = ArgumentHelpers.prepareArguments(options, callback);
                options = args.options;
                callback = Qext.makeNodeResolver(deferred, args.callback);

                if (!_.isFunction(callback)) {
                    callback = function () {
                    };
                }

                self.setValues(values, options, function (err, data) {
                    if (err) {
                        callback(err, data);
                    }
                    else {
                        self.insert(options, callback);
                    }
                });

                return deferred.promise;
            },

            /**
             * Updates values to model instance's 'data' property, validates data and updates instance directly into DB (only on successful validation).
             * Takes the union of options, which setValues and update take.
             *
             * @param query
             * @param values
             * @param [options]
             * @param [callback]
             */
            setValuesAndUpdate: function (query, values, options, callback) {
                var self = this;
                var deferred = Q.defer();

                var args = ArgumentHelpers.prepareArguments(options, callback);
                options = args.options;
                callback = Qext.makeNodeResolver(deferred, args.callback);

                if (!_.isFunction(callback)) {
                    callback = function () {
                    };
                }

                self.setValues(values, options, function (err, data) {
                    if (err) {
                        callback(err, data);
                    }
                    else {
                        // Check if query parameters are valid
                        self.schema.validate(query, {query: true, partial: true}, function (err, validatedQuery) {
                            if (err) {
                                callback(err, validatedQuery);
                            }
                            else {
                                self.update(validatedQuery, options, callback);
                            }
                        });


                    }
                });

                return deferred.promise;
            },

//            get: function (property) {
//                //TODO: check if allowed (if the property is publicly accesable)
//                return this[property];
//            },
//            set: function (property, value) {
//                //TODO: check if allowed (if the property is publicly accesable)
//                this[property] = value;
//            },

            /**
             * Inserts current model instance to database. Doesn't validate any data, since it is supposed to happen earlier.
             * @param options
             * @param callback
             */
            insert: function (options, callback) {
                var self = this;
                return self.schema._insertRaw(self.data, options, callback);
            },

            /**
             * Update current model instance to database. Doesn't validate any data, since it is supposed to happen earlier.
             * @param query
             * @param options
             * @param callback
             */
            update: function (query, options, callback) {
                var self = this;
                return self.schema._updateRaw(query, self.data, options, callback);
            }
        },
        //==================================
        // Schema members
        //==================================
        {
            newInstance: function (data) {
                var newInstance = new this();
                newInstance.data = data;
                return newInstance;
            },

            getPathPropertyValue: function (path) {
                var self = this;
                return MemberHelpers.getPathPropertyValue(self.prototype.data, path);
            },

            ensureSingleIndexes: function (callback) {
                var self = this;

                var deferred = Q.defer();
                callback = Qext.makeNodeResolver(deferred, callback);

                //get collection
                self.collection(function (err, collection) {
                    if (err) {
                        callback(err, collection);
                    }
                    else {
                        var indexNodesArray = ModelValidator.findNodes(self.prototype, 'index', true); //default: 'false'
                        var uniqueNodesArray = ModelValidator.findNodes(self.prototype, 'unique', true); //default: 'false'
                        var sparseNodesArray = ModelValidator.findNodes(self.prototype, 'sparse', true); //default: 'false'
                        var indexNodes = {};
                        var uniqueNodes = {};
                        var sparseNodes = {};

                        //convert arrays to dictionaries
                        _.forEach(indexNodesArray, function (path) {
                            indexNodes[path] = true;
                        });
                        _.forEach(uniqueNodesArray, function (path) {
                            uniqueNodes[path] = true;
                            if (!indexNodes[path]) {
                                //imply 'index' property to be 'true' for all nodes having 'unique' set to 'true'
                                indexNodes[path] = true;
                                indexNodesArray.push(path);
                            }
                        });
                        _.forEach(sparseNodesArray, function (path) {
                            sparseNodes[path] = true;
                        });

                        //call ensure index on all nodes having 'index' === 'true'
                        var paths, isUnique, isSparse;
                        Async.each(indexNodesArray, function (path, iterationCompleteCb) {
                            paths = {};
                            paths[path] = 1;
                            isUnique = (uniqueNodes[path] === true);
                            isSparse = (sparseNodes[path] === true);
                            collection.ensureIndex(paths, {unique: isUnique, sparse: isSparse}, iterationCompleteCb);
                        }, callback);
                    }
                });

                return deferred.promise;
            },

            ensureCompoundIndexes: function (callback) {
                var self = this;

                var deferred = Q.defer();
                callback = Qext.makeNodeResolver(deferred, callback);

                var compoundIndexes = self.prototype.compoundIndexes;

                if (!compoundIndexes || compoundIndexes.length == 0) {
                    //nothing to do
                    callback();
                }
                else {
                    //get collection
                    self.collection(function (err, collection) {
                        if (err) {
                            callback(err, collection);
                        }
                        else {
                            //create compund indexes
                            var paths, isUnique, isSparse;
                            Async.each(compoundIndexes, function (compoundIndex, iterationCompleteCb) {
                                if (!compoundIndex.fields || compoundIndex.fields.length == 0) {
                                    //can't create empty index
                                    iterationCompleteCb();
                                }
                                else {
                                    paths = {};
                                    _.forEach(compoundIndex.fields, function (path) {
                                        paths[path] = 1;
                                    });

                                    isUnique = (compoundIndex.unique === true);
                                    isSparse = (compoundIndex.sparse === true);
                                    collection.ensureIndex(paths, {
                                        unique: isUnique,
                                        sparse: isSparse
                                    }, iterationCompleteCb);
                                }
                            }, callback);
                        }
                    });
                }

                return deferred.promise;
            },

            ensureAllIndexes: function (callback) {
                var self = this;
                return Q.all([
                    self.ensureSingleIndexes(),
                    self.ensureCompoundIndexes()
                ]).spread(function (singleIndexResult, compountIndexResult) {
                    return Q(compountIndexResult);
                }).nodeify(callback);
            },

            /**
             * Validates provided 'values' against this model.
             * @param values
             * @param callback
             */
            validate: function (values, options, callback) {
                var deferred = Q.defer();
                var args = ArgumentHelpers.prepareArguments(options, callback)
                    , wrapper = {};
                options = args.options;
                callback = Qext.makeNodeResolver(deferred, args.callback);

                //Check for mongo's another possible syntax with '$' operators, e.g. '$set', '$setOnInsert' and set wrapper
                values = values || {};

                for (var element in values) {
                    if (element.match(/\$/i)) {
                        wrapper[element] = values[element];
                        options.flat = options.flat != undefined ? options.flat : true
                    }
                }

                // If nothing to wrap just validate values
                if (_.isEmpty(wrapper)) {
                    ModelValidator.validate(values, this.prototype, options, function (err, validatedValues) {
                        callback(err, validatedValues);
                    });
                }
                else {
                    // If wrapping elements like $set, $inc etc found, validate each and rewrite to values
                    values = {};
                    var errors = {};
                    var wrapperOptions = {};
                    for (var wrapperElem in wrapper) {

                        wrapperOptions = _.clone(options);
                        if (options && options.partial && _.isObject(options.partial)) {
                            if (options.partial[wrapperElem] !== undefined) {
                                wrapperOptions['partial'] = options.partial[wrapperElem];
                            }
                        }

                        if (options && options.validate && _.isObject(options.validate)) {
                            if (options.validate[wrapperElem] !== undefined) {
                                wrapperOptions['validate'] = options.validate[wrapperElem];
                            }
                        }

                        if (options.validate && options.validate[wrapperElem] === false) {
                            values[wrapperElem] = wrapper[wrapperElem];
                        }
                        else {
                            ModelValidator.validate(wrapper[wrapperElem], this.prototype, wrapperOptions, function (err, validatedValues) {
                                if (err) {
                                    errors = err;
                                }
                                values[wrapperElem] = validatedValues;
                            });
                        }
                    }

                    if (_.isEmpty(errors)) {
                        errors = null;
                    }
                    callback(errors, values);
                }

                return deferred.promise;
            },

            /**
             * Gets mongo database
             * @returns {Promise containing database object OR error}
             */
            db: function (callback) {
                return Qext.callNodeFunc({
                    obj: Shared.adapters("mongo"),
                    func: 'connect',
                    callback: callback
                }, this.dbName);
            },

            /**
             * Gets the collection of this model. Collection is specified in the 'collectionName' property of the model.
             */
            collection: function (callback) {
                var self = this;

                var deferred = Q.defer();
                callback = Qext.makeNodeResolver(deferred, callback);

                var breakExec = {};
                Async.waterfall([
                    function (next) {
                        if (self._collection) {
                            next(breakExec, self._collection);
                        }
                        else {
                            if (!self.collectionName) {
                                next({
                                    name: 'InternalError',
                                    err: "collectionName property is not set for model " + self.identity
                                });
                            }
                            else {
                                self.db(next);
                            }
                        }
                    },
                    function (db, next) {
                        //try to get exiting collection
                        db.collection(self.collectionName, {strict: true}, function (err, collection) {
                            if (!err) {
                                //collection exists already
                                self._collection = collection;
                                //do not apply indexes to exiting collection, since this operation is time consuming
                                next(breakExec, collection);
                            }
                            else {
                                var collectionOptions = self.collectionOptions || {};
                                db.createCollection(self.collectionName, collectionOptions, function (err, collection) {
                                    if (!err) {
                                        next(null, collection);
                                    }
                                    else {
                                        db.collection(self.collectionName, {strict: true}, function (err, collection) {
                                            if (!err) {
                                                //collection exists already
                                                self._collection = collection;
                                                //do not apply indexes to exiting collection, since this operation is time consuming
                                                next(breakExec, collection);
                                            }
                                            else {
                                                next(err);
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    },
                    function (collection, next) {
                        //store new collection
                        self._collection = collection;
                        //apply all indexes on collection
                        self.ensureAllIndexes(function (err) {
                            next(err, collection);
                        });
                    },
                    function (collection, next) {
                        //return collection
                        next(null, collection);
                    }
                ], function (err, collection) {
                    if (!err || err === breakExec) {
                        callback(null, collection);
                    }
                    else {
                        callback(err);
                    }
                });

                return deferred.promise;
            },

            _callGeneric: function (functionName, args) {
                var argData = ArgumentHelpers.prepareCallback(args);

                var callback = argData.callback;
                var args = argData.arguments;
                if (callback) {
                    args.pop();
                }

                return this.collection().then(function (collection) {
                    var deferred = Q.defer();
                    args.push(Qext.makeNodeResolver(deferred));
                    collection[functionName].apply(collection, args);
                    return deferred.promise;
                }).nodeify(callback);
            },

            /**
             * Same signature as in native mongo driver. Inserts a single document or a an array of documents into MongoDB. Validates documents before inserting them
             *
             * insert(docs[, options][, callback])
             *
             * Options
             *  - **w**, {Number/String, > -1 || 'majority' || tag name} the write concern for the operation where < 1 is no acknowlegement of write and w >= 1, w = 'majority' or tag acknowledges the write
             *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)
             *  - **fsync**, (Boolean, default:false) write waits for fsync before returning
             *  - **journal**, (Boolean, default:false) write waits for journal sync before returning
             *  - **continueOnError/keepGoing** {Boolean, default:false}, keep inserting documents even if one document has an error, *mongodb 1.9.1 >*.
             *  - **serializeFunctions** {Boolean, default:false}, serialize functions on the document.
             *  - **forceServerObjectId** {Boolean, default:false}, let server assign ObjectId instead of the driver
             *  - **validate**, data validation according to schema. If not specified is set to 'true', on explicit 'false' validation is skipped.
             *
             * Deprecated Options
             *  - **safe** {true | {w:n, wtimeout:n} | {fsync:true}, default:false}, executes with a getLastError command returning the results of the command on MongoDB.
             *
             * @param {Array|Object} docs
             * @param {Object} [options] optional options for insert command
             * @param {Function} [callback] optional callback for the function, must be provided when using a writeconcern
             * @return {null}
             * @api public
             */
            insert: function (docs, options, callback) {
                var self = this;
                var args = ArgumentHelpers.prepareArguments(options, callback);
                options = args.options;
                callback = args.callback;

                var result;
                if (options.validate === false) {
                    //insert unvalidated values
                    result = self._insertRaw(docs, options);
                }
                else {
                    result = self.validate(docs, options).then(function (validatedDocs) {
                        return self._insertRaw(validatedDocs, options);
                    });
                }

                return result.nodeify(callback);
            },

            update: function (query, docs, options, callback) {
                var self = this;
                var args = ArgumentHelpers.prepareArguments(options, callback);
                options = args.options;
                callback = args.callback;

                var result;
                if (options.validate === false) {
                    //insert unvalidated values
                    result = self._updateRaw(query, docs, options);
                }
                else {
                    result = self.validate(docs, options).then(function (validatedDocs) {
                        //validate and convert query parameters
                        return self.validate(query, {query: true, partial: true}).then(function (validatedQuery) {
                            return self._updateRaw(validatedQuery, validatedDocs, options);
                        });
                    });
                }

                return result.nodeify(callback);
            },

            _ensureIndex: function () {
                return this._callGeneric('ensureIndex', arguments);
            },

            _insertRaw: function () {
                return this._callGeneric('insert', arguments);
            },

            _updateRaw: function () {
                return this._callGeneric('update', arguments);
            },

            find: function () {
                return this._callGeneric('find', arguments);
            },

            remove: function () {
                return this._callGeneric('remove', arguments);
            },

            rename: function () {
                return this._callGeneric('rename', arguments);
            },

            distinct: function () {
                return this._callGeneric('distinct', arguments);
            },

            count: function () {
                return this._callGeneric('count', arguments);
            },

            drop: function () {
                return this._callGeneric('drop', arguments);
            },

            findAndModify: function () {
                return this._callGeneric('findAndModify', arguments);
            },

            findAndRemove: function () {
                return this._callGeneric('findAndRemove', arguments);
            },

            findOne: function () {
                return this._callGeneric('findOne', arguments);
            },

            createIndex: function () {
                return this._callGeneric('createIndex', arguments);
            },

            indexInformation: function () {
                return this._callGeneric('indexInformation', arguments);
            },

            dropIndex: function () {
                return this._callGeneric('dropIndex', arguments);
            },

            dropAllIndexes: function () {
                return this._callGeneric('dropAllIndexes', arguments);
            },

            reIndex: function () {
                return this._callGeneric('reIndex', arguments);
            },

            mapReduce: function () {
                return this._callGeneric('mapReduce', arguments);
            },

            group: function () {
                return this._callGeneric('group', arguments);
            },

            options: function () {
                return this._callGeneric('options', arguments);
            },

            isCapped: function () {
                return this._callGeneric('isCapped', arguments);
            },

            indexExists: function () {
                return this._callGeneric('indexExists', arguments);
            },

            geoNear: function () {
                return this._callGeneric('geoNear', arguments);
            },

            geoHaystackSearch: function () {
                return this._callGeneric('geoHaystackSearch', arguments);
            },

            indexes: function () {
                return this._callGeneric('indexes', arguments);
            },

            aggregate: function () {
                return this._callGeneric('aggregate', arguments);
            },

            stats: function () {
                return this._callGeneric('stats', arguments);
            }
        });

    return baseModel;
};

module.exports = thisModule();